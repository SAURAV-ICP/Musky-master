"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/contexts/UserContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/UserContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UserProvider: function() { return /* binding */ UserProvider; },\n/* harmony export */   useUser: function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index/index.mjs\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ UserProvider,useUser auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst UserContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    user: null,\n    loading: false,\n    error: null,\n    mutate: async ()=>{},\n    updateWalletAddress: async ()=>false\n});\nconst INITIAL_SPIN_ENERGY = 1200;\n// Admin ID for reference\nconst ADMIN_ID = \"7093793454\" || 0;\nfunction UserProvider(param) {\n    let { children } = param;\n    _s();\n    const [telegramUserId, setTelegramUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Extract Telegram user ID when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const getTelegramUser = ()=>{\n            try {\n                console.log(\"Attempting to get Telegram user ID...\");\n                // Check if we're in the Telegram WebApp environment\n                if ( true && window.Telegram) {\n                    console.log(\"Telegram WebApp detected\");\n                    // Try to get user from Telegram WebApp\n                    try {\n                        // Use type assertion to access potentially undefined properties\n                        const webApp = window.Telegram.WebApp;\n                        if (webApp && webApp.initDataUnsafe && webApp.initDataUnsafe.user) {\n                            const webAppUser = webApp.initDataUnsafe.user;\n                            if (webAppUser && webAppUser.id) {\n                                const userId = String(webAppUser.id);\n                                console.log(\"Found Telegram user from WebApp:\", userId);\n                                return userId;\n                            }\n                        }\n                    } catch (e) {\n                        console.error(\"Error accessing Telegram WebApp data:\", e);\n                    }\n                    // If we can't get the user from WebApp, try to parse it from the URL\n                    const tgWebAppData = new URLSearchParams(window.location.search).get(\"tgWebAppData\");\n                    if (tgWebAppData) {\n                        try {\n                            // Try to extract user_id from tgWebAppData\n                            const decodedData = decodeURIComponent(tgWebAppData);\n                            const userMatch = decodedData.match(/\"id\":(\\d+)/);\n                            if (userMatch && userMatch[1]) {\n                                const userId = userMatch[1];\n                                console.log(\"Found Telegram user from tgWebAppData:\", userId);\n                                return userId;\n                            }\n                        } catch (e) {\n                            console.error(\"Error parsing tgWebAppData:\", e);\n                        }\n                    }\n                }\n                // Check URL parameters as fallback\n                if (true) {\n                    const urlParams = new URLSearchParams(window.location.search);\n                    const userIdFromUrl = urlParams.get(\"user_id\") || urlParams.get(\"id\");\n                    if (userIdFromUrl) {\n                        console.log(\"Found user_id in URL:\", userIdFromUrl);\n                        return userIdFromUrl;\n                    }\n                    // Try to get user_id from hash\n                    const hash = window.location.hash;\n                    const hashParams = new URLSearchParams(hash.substring(1));\n                    const userIdFromHash = hashParams.get(\"user_id\") || hashParams.get(\"id\");\n                    if (userIdFromHash) {\n                        console.log(\"Found user_id in hash:\", userIdFromHash);\n                        return userIdFromHash;\n                    }\n                    // Try to get from localStorage (if previously saved)\n                    const savedUserId = localStorage.getItem(\"telegram_user_id\");\n                    if (savedUserId) {\n                        console.log(\"Found user_id in localStorage:\", savedUserId);\n                        return savedUserId;\n                    }\n                }\n                // For development/testing only - DO NOT use in production\n                if (true) {\n                    console.log(\"Development environment detected, using test user ID\");\n                    const testId = localStorage.getItem(\"test_user_id\") || \"test_user\";\n                    localStorage.setItem(\"test_user_id\", testId);\n                    return testId;\n                }\n                console.warn(\"No Telegram user ID found. This should only happen in development.\");\n                return null;\n            } catch (error) {\n                console.error(\"Error getting Telegram user:\", error);\n                return null;\n            }\n        };\n        const userId = getTelegramUser();\n        if (userId) {\n            setTelegramUserId(userId);\n            // Save to localStorage for persistence\n            if (true) {\n                localStorage.setItem(\"telegram_user_id\", userId);\n            }\n            console.log(\"Set Telegram user ID:\", userId);\n        } else {\n            console.error(\"Failed to get a valid user ID\");\n        }\n    }, []);\n    const { data: user, error, isLoading, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(telegramUserId ? [\n        \"user\",\n        telegramUserId\n    ] : null, async (param)=>{\n        let [_, userId] = param;\n        try {\n            console.log(\"Fetching user data for ID:\", userId);\n            // First, check if user exists\n            const { data: existingUser, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").select(\"*\").eq(\"user_id\", userId).single();\n            console.log(\"Existing user data:\", existingUser);\n            if (fetchError) {\n                if (fetchError.code === \"PGRST116\") {\n                    console.log(\"User not found, creating new user...\");\n                    // Create new user with initial spin energy\n                    const { data: newUser, error: createError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").insert({\n                        user_id: userId,\n                        telegram_id: userId,\n                        balance: 0,\n                        solana_balance: 0,\n                        energy: 1200,\n                        spin_energy: INITIAL_SPIN_ENERGY,\n                        last_spin_energy_reset: new Date().toISOString(),\n                        level: \"1\",\n                        is_admin: userId === ADMIN_ID,\n                        mining_equipment: {},\n                        mining_rate: 0 // Initialize mining rate to 0\n                    }).select().single();\n                    if (createError) {\n                        console.error(\"Error creating new user:\", createError);\n                        throw createError;\n                    }\n                    console.log(\"New user created:\", newUser);\n                    return newUser;\n                }\n                throw fetchError;\n            }\n            // If user exists but has no telegram_id, update it\n            if (existingUser && !existingUser.telegram_id) {\n                console.log(\"Updating user with telegram_id...\");\n                const { data: updatedUser, error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    telegram_id: userId\n                }).eq(\"user_id\", userId).select().single();\n                if (updateError) {\n                    console.error(\"Error updating user telegram_id:\", updateError);\n                } else {\n                    console.log(\"User updated with telegram_id:\", updatedUser);\n                    existingUser.telegram_id = userId;\n                }\n            }\n            // If user exists but has no spin energy, update them\n            if (existingUser && (existingUser.spin_energy === undefined || existingUser.spin_energy === null || existingUser.spin_energy === 0)) {\n                console.log(\"Updating user with spin energy...\");\n                const { data: updatedUser, error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    spin_energy: INITIAL_SPIN_ENERGY,\n                    last_spin_energy_reset: new Date().toISOString()\n                }).eq(\"user_id\", userId).select().single();\n                if (updateError) {\n                    console.error(\"Error updating user:\", updateError);\n                    throw updateError;\n                }\n                console.log(\"User updated with spin energy:\", updatedUser);\n                return updatedUser;\n            }\n            // Check if energy needs to be reset (12 hours passed)\n            if (existingUser.last_spin_energy_reset) {\n                const lastReset = new Date(existingUser.last_spin_energy_reset);\n                const now = new Date();\n                const hoursSinceReset = (now.getTime() - lastReset.getTime()) / (1000 * 60 * 60);\n                if (hoursSinceReset >= 12) {\n                    console.log(\"Resetting spin energy after 12 hours...\");\n                    const { data: resetUser, error: resetError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                        spin_energy: INITIAL_SPIN_ENERGY,\n                        last_spin_energy_reset: now.toISOString()\n                    }).eq(\"user_id\", userId).select().single();\n                    if (resetError) {\n                        console.error(\"Error resetting energy:\", resetError);\n                        throw resetError;\n                    }\n                    console.log(\"Energy reset complete:\", resetUser);\n                    return resetUser;\n                }\n            }\n            // Ensure is_admin is correctly set\n            if (existingUser.is_admin === true && userId !== ADMIN_ID) {\n                console.log(\"Fixing incorrect admin status for user:\", userId);\n                const { data: fixedUser, error: fixError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    is_admin: userId === ADMIN_ID\n                }).eq(\"user_id\", userId).select().single();\n                if (fixError) {\n                    console.error(\"Error fixing admin status:\", fixError);\n                } else if (fixedUser) {\n                    console.log(\"Admin status fixed for user:\", fixedUser);\n                    return fixedUser;\n                }\n            }\n            return existingUser;\n        } catch (error) {\n            console.error(\"Error in user data fetching:\", error);\n            throw error;\n        }\n    }, {\n        revalidateOnFocus: false,\n        revalidateOnReconnect: false,\n        refreshInterval: 60000\n    });\n    // Function to update wallet address\n    const updateWalletAddress = async (address)=>{\n        if (!user || !telegramUserId) {\n            console.error(\"Cannot update wallet address: User not logged in\");\n            return false;\n        }\n        try {\n            // Call the API endpoint to update the wallet address\n            const response = await fetch(\"/api/user/update-wallet\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    user_id: telegramUserId,\n                    wallet_address: address\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error(\"Failed to update wallet address:\", errorData);\n                return false;\n            }\n            // Refresh user data\n            await mutate();\n            return true;\n        } catch (error) {\n            console.error(\"Error updating wallet address:\", error);\n            return false;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(UserContext.Provider, {\n        value: {\n            user,\n            loading: isLoading,\n            error,\n            mutate,\n            updateWalletAddress\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/sauravlamichhane/Downloads/Musky-master/src/contexts/UserContext.tsx\",\n        lineNumber: 337,\n        columnNumber: 5\n    }, this);\n}\n_s(UserProvider, \"/iEAPaFT06pkzI2vqU2cafQJ2aU=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    ];\n});\n_c = UserProvider;\nfunction useUser() {\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(UserContext);\n}\n_s1(useUser, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9Vc2VyQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRThFO0FBQ3JEO0FBQ2lCO0FBZ0MxQyxNQUFNTyw0QkFBY04sb0RBQWFBLENBQWtCO0lBQ2pETyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxRQUFRLFdBQWE7SUFDckJDLHFCQUFxQixVQUFZO0FBQ25DO0FBRUEsTUFBTUMsc0JBQXNCO0FBQzVCLHlCQUF5QjtBQUN6QixNQUFNQyxXQUFXQyxZQUFnQyxJQUFJO0FBRTlDLFNBQVNHLGFBQWEsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQzs7SUFDM0IsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHbEIsK0NBQVFBLENBQWdCO0lBRXBFLGlEQUFpRDtJQUNqREMsZ0RBQVNBLENBQUM7UUFDUixNQUFNa0Isa0JBQWtCO1lBQ3RCLElBQUk7Z0JBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztnQkFFWixvREFBb0Q7Z0JBQ3BELElBQUksS0FBa0IsSUFBZUMsT0FBT0MsUUFBUSxFQUFFO29CQUNwREgsUUFBUUMsR0FBRyxDQUFDO29CQUVaLHVDQUF1QztvQkFDdkMsSUFBSTt3QkFDRixnRUFBZ0U7d0JBQ2hFLE1BQU1HLFNBQVNGLE9BQU9DLFFBQVEsQ0FBQ0UsTUFBTTt3QkFFckMsSUFBSUQsVUFBVUEsT0FBT0UsY0FBYyxJQUFJRixPQUFPRSxjQUFjLENBQUNyQixJQUFJLEVBQUU7NEJBQ2pFLE1BQU1zQixhQUFhSCxPQUFPRSxjQUFjLENBQUNyQixJQUFJOzRCQUU3QyxJQUFJc0IsY0FBY0EsV0FBV0MsRUFBRSxFQUFFO2dDQUMvQixNQUFNQyxTQUFTQyxPQUFPSCxXQUFXQyxFQUFFO2dDQUNuQ1IsUUFBUUMsR0FBRyxDQUFDLG9DQUFvQ1E7Z0NBQ2hELE9BQU9BOzRCQUNUO3dCQUNGO29CQUNGLEVBQUUsT0FBT0UsR0FBRzt3QkFDVlgsUUFBUWIs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ckQsTUFBTXdGLFdBQVcsTUFBTUMsTUFBTSwyQkFBMkI7Z0JBQ3REQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFDbkJuQyxTQUFTakQ7b0JBQ1RxRixnQkFBZ0JSO2dCQUNsQjtZQUNGO1lBRUEsSUFBSSxDQUFDQyxTQUFTUSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVQsU0FBU1UsSUFBSTtnQkFDckNyRixRQUFRYixLQUFLLENBQUMsb0NBQW9DaUc7Z0JBQ2xELE9BQU87WUFDVDtZQUVBLG9CQUFvQjtZQUNwQixNQUFNaEc7WUFDTixPQUFPO1FBQ1QsRUFBRSxPQUFPRCxPQUFPO1lBQ2RhLFFBQVFiLEtBQUssQ0FBQyxrQ0FBa0NBO1lBQ2hELE9BQU87UUFDVDtJQUNGO0lBRUEscUJBQ0UsOERBQUNILFlBQVlzRyxRQUFRO1FBQ25CQyxPQUFPO1lBQ0x0RztZQUNBQyxTQUFTZ0Q7WUFDVC9DO1lBQ0FDO1lBQ0FDO1FBQ0Y7a0JBRUNPOzs7Ozs7QUFHUDtHQTVTZ0JEOztRQXdHbUNiLDJDQUFNQTs7O0tBeEd6Q2E7QUE4U1QsU0FBUzZGOztJQUNkLE9BQU83RyxpREFBVUEsQ0FBQ0s7QUFDcEI7SUFGZ0J3RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29udGV4dHMvVXNlckNvbnRleHQudHN4PzVlZTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG4vLyBObyBuZWVkIHRvIHJlZGVmaW5lIHRoZSBXaW5kb3cgaW50ZXJmYWNlIGFzIGl0J3MgYWxyZWFkeSBkZWZpbmVkIGluIGdsb2JhbC5kLnRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIHN0YXJzX2JhbGFuY2U6IG51bWJlcjtcbiAgdXNlcl9pZDogc3RyaW5nO1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBiYWxhbmNlOiBudW1iZXI7XG4gIHNvbGFuYV9iYWxhbmNlOiBudW1iZXI7XG4gIGVuZXJneTogbnVtYmVyO1xuICBzcGluX2VuZXJneTogbnVtYmVyO1xuICBsYXN0X3NwaW5fZW5lcmd5X3Jlc2V0OiBzdHJpbmcgfCBudWxsO1xuICBsYXN0X2VuZXJneV9yZXNldDogc3RyaW5nIHwgbnVsbDtcbiAgbGFzdF90YXBfdGltZTogc3RyaW5nIHwgbnVsbDtcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG4gIGxldmVsOiBzdHJpbmc7XG4gIGlzX2FkbWluOiBib29sZWFuO1xuICBzb2xhbmFfYWRkcmVzczogc3RyaW5nIHwgbnVsbDtcbiAgbWluaW5nX3JhdGU6IG51bWJlcjtcbiAgdGVsZWdyYW1faWQ6IHN0cmluZyB8IG51bGw7XG59XG5cbmludGVyZmFjZSBVc2VyQ29udGV4dFR5cGUge1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IGFueTtcbiAgbXV0YXRlOiAoKSA9PiBQcm9taXNlPGFueT47XG4gIHVwZGF0ZVdhbGxldEFkZHJlc3M6IChhZGRyZXNzOiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj47XG59XG5cbmNvbnN0IFVzZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VyQ29udGV4dFR5cGU+KHtcbiAgdXNlcjogbnVsbCxcbiAgbG9hZGluZzogZmFsc2UsXG4gIGVycm9yOiBudWxsLFxuICBtdXRhdGU6IGFzeW5jICgpID0+IHt9LFxuICB1cGRhdGVXYWxsZXRBZGRyZXNzOiBhc3luYyAoKSA9PiBmYWxzZSxcbn0pO1xuXG5jb25zdCBJTklUSUFMX1NQSU5fRU5FUkdZID0gMTIwMDtcbi8vIEFkbWluIElEIGZvciByZWZlcmVuY2VcbmNvbnN0IEFETUlOX0lEID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQURNSU5fSUQgfHwgJzcwOTM3OTM0NTQnO1xuXG5leHBvcnQgZnVuY3Rpb24gVXNlclByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW3RlbGVncmFtVXNlcklkLCBzZXRUZWxlZ3JhbVVzZXJJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgXG4gIC8vIEV4dHJhY3QgVGVsZWdyYW0gdXNlciBJRCB3aGVuIGNvbXBvbmVudCBtb3VudHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBnZXRUZWxlZ3JhbVVzZXIgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBnZXQgVGVsZWdyYW0gdXNlciBJRC4uLicpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gdGhlIFRlbGVncmFtIFdlYkFwcCBlbnZpcm9ubWVudFxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlRlbGVncmFtKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1RlbGVncmFtIFdlYkFwcCBkZXRlY3RlZCcpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBnZXQgdXNlciBmcm9tIFRlbGVncmFtIFdlYkFwcFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2UgdHlwZSBhc3NlcnRpb24gdG8gYWNjZXNzIHBvdGVudGlhbGx5IHVuZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCB3ZWJBcHAgPSB3aW5kb3cuVGVsZWdyYW0uV2ViQXBwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAod2ViQXBwICYmIHdlYkFwcC5pbml0RGF0YVVuc2FmZSAmJiB3ZWJBcHAuaW5pdERhdGFVbnNhZmUudXNlcikge1xuICAgICAgICAgICAgICBjb25zdCB3ZWJBcHBVc2VyID0gd2ViQXBwLmluaXREYXRhVW5zYWZlLnVzZXI7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAod2ViQXBwVXNlciAmJiB3ZWJBcHBVc2VyLmlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcklkID0gU3RyaW5nKHdlYkFwcFVzZXIuaWQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBUZWxlZ3JhbSB1c2VyIGZyb20gV2ViQXBwOicsIHVzZXJJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBUZWxlZ3JhbSBXZWJBcHAgZGF0YTonLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgZ2V0IHRoZSB1c2VyIGZyb20gV2ViQXBwLCB0cnkgdG8gcGFyc2UgaXQgZnJvbSB0aGUgVVJMXG4gICAgICAgICAgY29uc3QgdGdXZWJBcHBEYXRhID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQoJ3RnV2ViQXBwRGF0YScpO1xuICAgICAgICAgIGlmICh0Z1dlYkFwcERhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIFRyeSB0byBleHRyYWN0IHVzZXJfaWQgZnJvbSB0Z1dlYkFwcERhdGFcbiAgICAgICAgICAgICAgY29uc3QgZGVjb2RlZERhdGEgPSBkZWNvZGVVUklDb21wb25lbnQodGdXZWJBcHBEYXRhKTtcbiAgICAgICAgICAgICAgY29uc3QgdXNlck1hdGNoID0gZGVjb2RlZERhdGEubWF0Y2goL1wiaWRcIjooXFxkKykvKTtcbiAgICAgICAgICAgICAgaWYgKHVzZXJNYXRjaCAmJiB1c2VyTWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VySWQgPSB1c2VyTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIFRlbGVncmFtIHVzZXIgZnJvbSB0Z1dlYkFwcERhdGE6JywgdXNlcklkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlcklkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgdGdXZWJBcHBEYXRhOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgVVJMIHBhcmFtZXRlcnMgYXMgZmFsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgICBjb25zdCB1c2VySWRGcm9tVXJsID0gdXJsUGFyYW1zLmdldCgndXNlcl9pZCcpIHx8IHVybFBhcmFtcy5nZXQoJ2lkJyk7XG4gICAgICAgICAgaWYgKHVzZXJJZEZyb21VcmwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCB1c2VyX2lkIGluIFVSTDonLCB1c2VySWRGcm9tVXJsKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VySWRGcm9tVXJsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IHVzZXJfaWQgZnJvbSBoYXNoXG4gICAgICAgICAgY29uc3QgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgICAgICAgIGNvbnN0IGhhc2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICBjb25zdCB1c2VySWRGcm9tSGFzaCA9IGhhc2hQYXJhbXMuZ2V0KCd1c2VyX2lkJykgfHwgaGFzaFBhcmFtcy5nZXQoJ2lkJyk7XG4gICAgICAgICAgaWYgKHVzZXJJZEZyb21IYXNoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgdXNlcl9pZCBpbiBoYXNoOicsIHVzZXJJZEZyb21IYXNoKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VySWRGcm9tSGFzaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBmcm9tIGxvY2FsU3RvcmFnZSAoaWYgcHJldmlvdXNseSBzYXZlZClcbiAgICAgICAgICBjb25zdCBzYXZlZFVzZXJJZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0ZWxlZ3JhbV91c2VyX2lkJyk7XG4gICAgICAgICAgaWYgKHNhdmVkVXNlcklkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgdXNlcl9pZCBpbiBsb2NhbFN0b3JhZ2U6Jywgc2F2ZWRVc2VySWQpO1xuICAgICAgICAgICAgcmV0dXJuIHNhdmVkVXNlcklkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRm9yIGRldmVsb3BtZW50L3Rlc3Rpbmcgb25seSAtIERPIE5PVCB1c2UgaW4gcHJvZHVjdGlvblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnRGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQgZGV0ZWN0ZWQsIHVzaW5nIHRlc3QgdXNlciBJRCcpO1xuICAgICAgICAgIGNvbnN0IHRlc3RJZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0ZXN0X3VzZXJfaWQnKSB8fCAndGVzdF91c2VyJztcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndGVzdF91c2VyX2lkJywgdGVzdElkKTtcbiAgICAgICAgICByZXR1cm4gdGVzdElkO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIFRlbGVncmFtIHVzZXIgSUQgZm91bmQuIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGluIGRldmVsb3BtZW50LicpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgVGVsZWdyYW0gdXNlcjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgY29uc3QgdXNlcklkID0gZ2V0VGVsZWdyYW1Vc2VyKCk7XG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgc2V0VGVsZWdyYW1Vc2VySWQodXNlcklkKTtcbiAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlIGZvciBwZXJzaXN0ZW5jZVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0ZWxlZ3JhbV91c2VyX2lkJywgdXNlcklkKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCdTZXQgVGVsZWdyYW0gdXNlciBJRDonLCB1c2VySWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGEgdmFsaWQgdXNlciBJRCcpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHsgZGF0YTogdXNlciwgZXJyb3IsIGlzTG9hZGluZywgbXV0YXRlIH0gPSB1c2VTV1IoXG4gICAgdGVsZWdyYW1Vc2VySWQgPyBbJ3VzZXInLCB0ZWxlZ3JhbVVzZXJJZF0gOiBudWxsLCBcbiAgICBhc3luYyAoW18sIHVzZXJJZF0pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyB1c2VyIGRhdGEgZm9yIElEOicsIHVzZXJJZCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdXNlciBleGlzdHNcbiAgICAgICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ1VzZXIsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnRXhpc3RpbmcgdXNlciBkYXRhOicsIGV4aXN0aW5nVXNlcik7XG4gICAgICAgIFxuICAgICAgICBpZiAoZmV0Y2hFcnJvcikge1xuICAgICAgICAgIGlmIChmZXRjaEVycm9yLmNvZGUgPT09ICdQR1JTVDExNicpIHsgLy8gTm90IGZvdW5kIGVycm9yXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciBub3QgZm91bmQsIGNyZWF0aW5nIG5ldyB1c2VyLi4uJyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHVzZXIgd2l0aCBpbml0aWFsIHNwaW4gZW5lcmd5XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IG5ld1VzZXIsIGVycm9yOiBjcmVhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgICAgIHRlbGVncmFtX2lkOiB1c2VySWQsIC8vIFN0b3JlIHRoZSB0ZWxlZ3JhbV9pZCBleHBsaWNpdGx5XG4gICAgICAgICAgICAgICAgYmFsYW5jZTogMCxcbiAgICAgICAgICAgICAgICBzb2xhbmFfYmFsYW5jZTogMCxcbiAgICAgICAgICAgICAgICBlbmVyZ3k6IDEyMDAsXG4gICAgICAgICAgICAgICAgc3Bpbl9lbmVyZ3k6IElOSVRJQUxfU1BJTl9FTkVSR1ksXG4gICAgICAgICAgICAgICAgbGFzdF9zcGluX2VuZXJneV9yZXNldDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnMScsXG4gICAgICAgICAgICAgICAgaXNfYWRtaW46IHVzZXJJZCA9PT0gQURNSU5fSUQsIC8vIE9ubHkgc2V0IGFkbWluIGlmIGl0IG1hdGNoZXMgQURNSU5fSURcbiAgICAgICAgICAgICAgICBtaW5pbmdfZXF1aXBtZW50OiB7fSwgLy8gSW5pdGlhbGl6ZSBlbXB0eSBtaW5pbmcgZXF1aXBtZW50XG4gICAgICAgICAgICAgICAgbWluaW5nX3JhdGU6IDAgLy8gSW5pdGlhbGl6ZSBtaW5pbmcgcmF0ZSB0byAwXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICAgIGlmIChjcmVhdGVFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBuZXcgdXNlcjonLCBjcmVhdGVFcnJvcik7XG4gICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ05ldyB1c2VyIGNyZWF0ZWQ6JywgbmV3VXNlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3VXNlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZmV0Y2hFcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHVzZXIgZXhpc3RzIGJ1dCBoYXMgbm8gdGVsZWdyYW1faWQsIHVwZGF0ZSBpdFxuICAgICAgICBpZiAoZXhpc3RpbmdVc2VyICYmICFleGlzdGluZ1VzZXIudGVsZWdyYW1faWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgdXNlciB3aXRoIHRlbGVncmFtX2lkLi4uJyk7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkVXNlciwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgICB0ZWxlZ3JhbV9pZDogdXNlcklkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHVzZXIgdGVsZWdyYW1faWQ6JywgdXBkYXRlRXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciB1cGRhdGVkIHdpdGggdGVsZWdyYW1faWQ6JywgdXBkYXRlZFVzZXIpO1xuICAgICAgICAgICAgZXhpc3RpbmdVc2VyLnRlbGVncmFtX2lkID0gdXNlcklkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHVzZXIgZXhpc3RzIGJ1dCBoYXMgbm8gc3BpbiBlbmVyZ3ksIHVwZGF0ZSB0aGVtXG4gICAgICAgIGlmIChleGlzdGluZ1VzZXIgJiYgKGV4aXN0aW5nVXNlci5zcGluX2VuZXJneSA9PT0gdW5kZWZpbmVkIHx8IGV4aXN0aW5nVXNlci5zcGluX2VuZXJneSA9PT0gbnVsbCB8fCBleGlzdGluZ1VzZXIuc3Bpbl9lbmVyZ3kgPT09IDApKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHVzZXIgd2l0aCBzcGluIGVuZXJneS4uLicpO1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlZFVzZXIsIGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgc3Bpbl9lbmVyZ3k6IElOSVRJQUxfU1BJTl9FTkVSR1ksXG4gICAgICAgICAgICAgIGxhc3Rfc3Bpbl9lbmVyZ3lfcmVzZXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdXNlcjonLCB1cGRhdGVFcnJvcik7XG4gICAgICAgICAgICB0aHJvdyB1cGRhdGVFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgdXBkYXRlZCB3aXRoIHNwaW4gZW5lcmd5OicsIHVwZGF0ZWRVc2VyKTtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlZFVzZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBlbmVyZ3kgbmVlZHMgdG8gYmUgcmVzZXQgKDEyIGhvdXJzIHBhc3NlZClcbiAgICAgICAgaWYgKGV4aXN0aW5nVXNlci5sYXN0X3NwaW5fZW5lcmd5X3Jlc2V0KSB7XG4gICAgICAgICAgY29uc3QgbGFzdFJlc2V0ID0gbmV3IERhdGUoZXhpc3RpbmdVc2VyLmxhc3Rfc3Bpbl9lbmVyZ3lfcmVzZXQpO1xuICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgY29uc3QgaG91cnNTaW5jZVJlc2V0ID0gKG5vdy5nZXRUaW1lKCkgLSBsYXN0UmVzZXQuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGhvdXJzU2luY2VSZXNldCA+PSAxMikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc2V0dGluZyBzcGluIGVuZXJneSBhZnRlciAxMiBob3Vycy4uLicpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZXNldFVzZXIsIGVycm9yOiByZXNldEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzcGluX2VuZXJneTogSU5JVElBTF9TUElOX0VORVJHWSxcbiAgICAgICAgICAgICAgICBsYXN0X3NwaW5fZW5lcmd5X3Jlc2V0OiBub3cudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICBpZiAocmVzZXRFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNldHRpbmcgZW5lcmd5OicsIHJlc2V0RXJyb3IpO1xuICAgICAgICAgICAgICB0aHJvdyByZXNldEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0VuZXJneSByZXNldCBjb21wbGV0ZTonLCByZXNldFVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0VXNlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgaXNfYWRtaW4gaXMgY29ycmVjdGx5IHNldFxuICAgICAgICBpZiAoZXhpc3RpbmdVc2VyLmlzX2FkbWluID09PSB0cnVlICYmIHVzZXJJZCAhPT0gQURNSU5fSUQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnRml4aW5nIGluY29ycmVjdCBhZG1pbiBzdGF0dXMgZm9yIHVzZXI6JywgdXNlcklkKTtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IGZpeGVkVXNlciwgZXJyb3I6IGZpeEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgICBpc19hZG1pbjogdXNlcklkID09PSBBRE1JTl9JRFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgaWYgKGZpeEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaXhpbmcgYWRtaW4gc3RhdHVzOicsIGZpeEVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpeGVkVXNlcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkbWluIHN0YXR1cyBmaXhlZCBmb3IgdXNlcjonLCBmaXhlZFVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZpeGVkVXNlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBleGlzdGluZ1VzZXI7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB1c2VyIGRhdGEgZmV0Y2hpbmc6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIHJldmFsaWRhdGVPbkZvY3VzOiBmYWxzZSxcbiAgICAgIHJldmFsaWRhdGVPblJlY29ubmVjdDogZmFsc2UsXG4gICAgICByZWZyZXNoSW50ZXJ2YWw6IDYwMDAwLCAvLyBSZWZyZXNoIGV2ZXJ5IG1pbnV0ZVxuICAgIH1cbiAgKTtcblxuICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgd2FsbGV0IGFkZHJlc3NcbiAgY29uc3QgdXBkYXRlV2FsbGV0QWRkcmVzcyA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBpZiAoIXVzZXIgfHwgIXRlbGVncmFtVXNlcklkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgdXBkYXRlIHdhbGxldCBhZGRyZXNzOiBVc2VyIG5vdCBsb2dnZWQgaW4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2FsbCB0aGUgQVBJIGVuZHBvaW50IHRvIHVwZGF0ZSB0aGUgd2FsbGV0IGFkZHJlc3NcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvdXNlci91cGRhdGUtd2FsbGV0Jywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB1c2VyX2lkOiB0ZWxlZ3JhbVVzZXJJZCxcbiAgICAgICAgICB3YWxsZXRfYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgd2FsbGV0IGFkZHJlc3M6JywgZXJyb3JEYXRhKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWZyZXNoIHVzZXIgZGF0YVxuICAgICAgYXdhaXQgbXV0YXRlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgd2FsbGV0IGFkZHJlc3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxVc2VyQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgdXNlcixcbiAgICAgICAgbG9hZGluZzogaXNMb2FkaW5nLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgbXV0YXRlLFxuICAgICAgICB1cGRhdGVXYWxsZXRBZGRyZXNzLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Vc2VyQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVzZXIoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFVzZXJDb250ZXh0KTtcbn0gIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVNXUiIsInN1cGFiYXNlIiwiVXNlckNvbnRleHQiLCJ1c2VyIiwibG9hZGluZyIsImVycm9yIiwibXV0YXRlIiwidXBkYXRlV2FsbGV0QWRkcmVzcyIsIklOSVRJQUxfU1BJTl9FTkVSR1kiLCJBRE1JTl9JRCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BRE1JTl9JRCIsIlVzZXJQcm92aWRlciIsImNoaWxkcmVuIiwidGVsZWdyYW1Vc2VySWQiLCJzZXRUZWxlZ3JhbVVzZXJJZCIsImdldFRlbGVncmFtVXNlciIsImNvbnNvbGUiLCJsb2ciLCJ3aW5kb3ciLCJUZWxlZ3JhbSIsIndlYkFwcCIsIldlYkFwcCIsImluaXREYXRhVW5zYWZlIiwid2ViQXBwVXNlciIsImlkIiwidXNlcklkIiwiU3RyaW5nIiwiZSIsInRnV2ViQXBwRGF0YSIsIlVSTFNlYXJjaFBhcmFtcyIsImxvY2F0aW9uIiwic2VhcmNoIiwiZ2V0IiwiZGVjb2RlZERhdGEiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ1c2VyTWF0Y2giLCJtYXRjaCIsInVybFBhcmFtcyIsInVzZXJJZEZyb21VcmwiLCJoYXNoIiwiaGFzaFBhcmFtcyIsInN1YnN0cmluZyIsInVzZXJJZEZyb21IYXNoIiwic2F2ZWRVc2VySWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidGVzdElkIiwic2V0SXRlbSIsIndhcm4iLCJkYXRhIiwiaXNMb2FkaW5nIiwiXyIsImV4aXN0aW5nVXNlciIsImZldGNoRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJjb2RlIiwibmV3VXNlciIsImNyZWF0ZUVycm9yIiwiaW5zZXJ0IiwidXNlcl9pZCIsInRlbGVncmFtX2lkIiwiYmFsYW5jZSIsInNvbGFuYV9iYWxhbmNlIiwiZW5lcmd5Iiwic3Bpbl9lbmVyZ3kiLCJsYXN0X3NwaW5fZW5lcmd5X3Jlc2V0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibGV2ZWwiLCJpc19hZG1pbiIsIm1pbmluZ19lcXVpcG1lbnQiLCJtaW5pbmdfcmF0ZSIsInVwZGF0ZWRVc2VyIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJ1bmRlZmluZWQiLCJsYXN0UmVzZXQiLCJub3ciLCJob3Vyc1NpbmNlUmVzZXQiLCJnZXRUaW1lIiwicmVzZXRVc2VyIiwicmVzZXRFcnJvciIsImZpeGVkVXNlciIsImZpeEVycm9yIiwicmV2YWxpZGF0ZU9uRm9jdXMiLCJyZXZhbGlkYXRlT25SZWNvbm5lY3QiLCJyZWZyZXNoSW50ZXJ2YWwiLCJhZGRyZXNzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIndhbGxldF9hZGRyZXNzIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZVVzZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/UserContext.tsx\n"));

/***/ })

});