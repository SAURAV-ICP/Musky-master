"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tasks/page",{

/***/ "(app-pages-browser)/./src/contexts/UserContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/UserContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UserProvider: function() { return /* binding */ UserProvider; },\n/* harmony export */   useUser: function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index/index.mjs\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ UserProvider,useUser auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst UserContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    user: null,\n    loading: false,\n    error: null,\n    mutate: async ()=>{}\n});\nconst INITIAL_SPIN_ENERGY = 1200;\n// Admin ID for reference\nconst ADMIN_ID = \"7093793454\" || 0;\nfunction UserProvider(param) {\n    let { children } = param;\n    _s();\n    const [telegramUserId, setTelegramUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Extract Telegram user ID when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const getTelegramUser = ()=>{\n            try {\n                console.log(\"Attempting to get Telegram user ID...\");\n                // Check if we're in the Telegram WebApp environment\n                if ( true && window.Telegram) {\n                    console.log(\"Telegram WebApp detected\");\n                    // Try to get user from Telegram WebApp\n                    try {\n                        // Use type assertion to access potentially undefined properties\n                        const webApp = window.Telegram.WebApp;\n                        if (webApp && webApp.initDataUnsafe && webApp.initDataUnsafe.user) {\n                            const webAppUser = webApp.initDataUnsafe.user;\n                            if (webAppUser && webAppUser.id) {\n                                const userId = String(webAppUser.id);\n                                console.log(\"Found Telegram user from WebApp:\", userId);\n                                return userId;\n                            }\n                        }\n                    } catch (e) {\n                        console.error(\"Error accessing Telegram WebApp data:\", e);\n                    }\n                    // If we can't get the user from WebApp, try to parse it from the URL\n                    const tgWebAppData = new URLSearchParams(window.location.search).get(\"tgWebAppData\");\n                    if (tgWebAppData) {\n                        try {\n                            // Try to extract user_id from tgWebAppData\n                            const decodedData = decodeURIComponent(tgWebAppData);\n                            const userMatch = decodedData.match(/\"id\":(\\d+)/);\n                            if (userMatch && userMatch[1]) {\n                                const userId = userMatch[1];\n                                console.log(\"Found Telegram user from tgWebAppData:\", userId);\n                                return userId;\n                            }\n                        } catch (e) {\n                            console.error(\"Error parsing tgWebAppData:\", e);\n                        }\n                    }\n                }\n                // Check URL parameters as fallback\n                if (true) {\n                    const urlParams = new URLSearchParams(window.location.search);\n                    const userIdFromUrl = urlParams.get(\"user_id\") || urlParams.get(\"id\");\n                    if (userIdFromUrl) {\n                        console.log(\"Found user_id in URL:\", userIdFromUrl);\n                        return userIdFromUrl;\n                    }\n                    // Try to get user_id from hash\n                    const hash = window.location.hash;\n                    const hashParams = new URLSearchParams(hash.substring(1));\n                    const userIdFromHash = hashParams.get(\"user_id\") || hashParams.get(\"id\");\n                    if (userIdFromHash) {\n                        console.log(\"Found user_id in hash:\", userIdFromHash);\n                        return userIdFromHash;\n                    }\n                    // Try to get from localStorage (if previously saved)\n                    const savedUserId = localStorage.getItem(\"telegram_user_id\");\n                    if (savedUserId) {\n                        console.log(\"Found user_id in localStorage:\", savedUserId);\n                        return savedUserId;\n                    }\n                }\n                // For development/testing only - DO NOT use in production\n                if (true) {\n                    console.log(\"Development environment detected, using test user ID\");\n                    const testId = localStorage.getItem(\"test_user_id\") || \"test_user\";\n                    localStorage.setItem(\"test_user_id\", testId);\n                    return testId;\n                }\n                console.warn(\"No Telegram user ID found. This should only happen in development.\");\n                return null;\n            } catch (error) {\n                console.error(\"Error getting Telegram user:\", error);\n                return null;\n            }\n        };\n        const userId = getTelegramUser();\n        if (userId) {\n            setTelegramUserId(userId);\n            // Save to localStorage for persistence\n            if (true) {\n                localStorage.setItem(\"telegram_user_id\", userId);\n            }\n            console.log(\"Set Telegram user ID:\", userId);\n        } else {\n            console.error(\"Failed to get a valid user ID\");\n        }\n    }, []);\n    const { data: user, error, isLoading, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(telegramUserId ? [\n        \"user\",\n        telegramUserId\n    ] : null, async (param)=>{\n        let [_, userId] = param;\n        try {\n            console.log(\"Fetching user data for ID:\", userId);\n            // First, check if user exists\n            const { data: existingUser, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").select(\"*\").eq(\"user_id\", userId).single();\n            console.log(\"Existing user data:\", existingUser);\n            if (fetchError) {\n                if (fetchError.code === \"PGRST116\") {\n                    console.log(\"User not found, creating new user...\");\n                    // Create new user with initial spin energy\n                    const { data: newUser, error: createError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").insert({\n                        user_id: userId,\n                        telegram_id: userId,\n                        balance: 0,\n                        solana_balance: 0,\n                        energy: 1200,\n                        spin_energy: INITIAL_SPIN_ENERGY,\n                        last_spin_energy_reset: new Date().toISOString(),\n                        level: \"1\",\n                        is_admin: userId === ADMIN_ID,\n                        mining_equipment: {},\n                        mining_rate: 0 // Initialize mining rate to 0\n                    }).select().single();\n                    if (createError) {\n                        console.error(\"Error creating new user:\", createError);\n                        throw createError;\n                    }\n                    console.log(\"New user created:\", newUser);\n                    return newUser;\n                }\n                throw fetchError;\n            }\n            // If user exists but has no telegram_id, update it\n            if (existingUser && !existingUser.telegram_id) {\n                console.log(\"Updating user with telegram_id...\");\n                const { data: updatedUser, error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    telegram_id: userId\n                }).eq(\"user_id\", userId).select().single();\n                if (updateError) {\n                    console.error(\"Error updating user telegram_id:\", updateError);\n                } else {\n                    console.log(\"User updated with telegram_id:\", updatedUser);\n                    existingUser.telegram_id = userId;\n                }\n            }\n            // If user exists but has no spin energy, update them\n            if (existingUser && (existingUser.spin_energy === undefined || existingUser.spin_energy === null || existingUser.spin_energy === 0)) {\n                console.log(\"Updating user with spin energy...\");\n                const { data: updatedUser, error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    spin_energy: INITIAL_SPIN_ENERGY,\n                    last_spin_energy_reset: new Date().toISOString()\n                }).eq(\"user_id\", userId).select().single();\n                if (updateError) {\n                    console.error(\"Error updating user:\", updateError);\n                    throw updateError;\n                }\n                console.log(\"User updated with spin energy:\", updatedUser);\n                return updatedUser;\n            }\n            // Check if energy needs to be reset (12 hours passed)\n            if (existingUser.last_spin_energy_reset) {\n                const lastReset = new Date(existingUser.last_spin_energy_reset);\n                const now = new Date();\n                const hoursSinceReset = (now.getTime() - lastReset.getTime()) / (1000 * 60 * 60);\n                if (hoursSinceReset >= 12) {\n                    console.log(\"Resetting spin energy after 12 hours...\");\n                    const { data: resetUser, error: resetError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                        spin_energy: INITIAL_SPIN_ENERGY,\n                        last_spin_energy_reset: now.toISOString()\n                    }).eq(\"user_id\", userId).select().single();\n                    if (resetError) {\n                        console.error(\"Error resetting energy:\", resetError);\n                        throw resetError;\n                    }\n                    console.log(\"Energy reset complete:\", resetUser);\n                    return resetUser;\n                }\n            }\n            // Ensure is_admin is correctly set\n            if (existingUser.is_admin === true && userId !== ADMIN_ID) {\n                console.log(\"Fixing incorrect admin status for user:\", userId);\n                const { data: fixedUser, error: fixError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    is_admin: userId === ADMIN_ID\n                }).eq(\"user_id\", userId).select().single();\n                if (fixError) {\n                    console.error(\"Error fixing admin status:\", fixError);\n                } else if (fixedUser) {\n                    console.log(\"Admin status fixed for user:\", fixedUser);\n                    return fixedUser;\n                }\n            }\n            return existingUser;\n        } catch (error) {\n            console.error(\"Error in user data fetching:\", error);\n            throw error;\n        }\n    }, {\n        revalidateOnFocus: false,\n        revalidateOnReconnect: false,\n        refreshInterval: 60000\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(UserContext.Provider, {\n        value: {\n            user,\n            loading: isLoading,\n            error,\n            mutate\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/sauravlamichhane/Downloads/Musky-master/src/contexts/UserContext.tsx\",\n        lineNumber: 300,\n        columnNumber: 5\n    }, this);\n}\n_s(UserProvider, \"/iEAPaFT06pkzI2vqU2cafQJ2aU=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    ];\n});\n_c = UserProvider;\nfunction useUser() {\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(UserContext);\n}\n_s1(useUser, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9Vc2VyQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRThFO0FBQ3JEO0FBQ2lCO0FBK0IxQyxNQUFNTyw0QkFBY04sb0RBQWFBLENBQWtCO0lBQ2pETyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxRQUFRLFdBQWE7QUFDdkI7QUFFQSxNQUFNQyxzQkFBc0I7QUFDNUIseUJBQXlCO0FBQ3pCLE1BQU1DLFdBQVdDLFlBQWdDLElBQUk7QUFFOUMsU0FBU0csYUFBYSxLQUEyQztRQUEzQyxFQUFFQyxRQUFRLEVBQWlDLEdBQTNDOztJQUMzQixNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdqQiwrQ0FBUUEsQ0FBZ0I7SUFFcEUsaURBQWlEO0lBQ2pEQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1pQixrQkFBa0I7WUFDdEIsSUFBSTtnQkFDRkMsUUFBUUMsR0FBRyxDQUFDO2dCQUVaLG9EQUFvRDtnQkFDcEQsSUFBSSxLQUFrQixJQUFlQyxPQUFPQyxRQUFRLEVBQUU7b0JBQ3BESCxRQUFRQyxHQUFHLENBQUM7b0JBRVosdUNBQXVDO29CQUN2QyxJQUFJO3dCQUNGLGdFQUFnRTt3QkFDaEUsTUFBTUcsU0FBU0YsT0FBT0MsUUFBUSxDQUFDRSxNQUFNO3dCQUVyQyxJQUFJRCxVQUFVQSxPQUFPRSxjQUFjLElBQUlGLE9BQU9FLGNBQWMsQ0FBQ3BCLElBQUksRUFBRTs0QkFDakUsTUFBTXFCLGFBQWFILE9BQU9FLGNBQWMsQ0FBQ3BCLElBQUk7NEJBRTdDLElBQUlxQixjQUFjQSxXQUFXQyxFQUFFLEVBQUU7Z0NBQy9CLE1BQU1DLFNBQVNDLE9BQU9ILFdBQVdDLEVBQUU7Z0NBQ25DUixRQUFRQyxHQUFHLENBQUMsb0NBQW9DUTtnQ0FDaEQsT0FBT0E7NEJBQ1Q7d0JBQ0Y7b0JBQ0YsRUFBRSxPQUFPRSxHQUFHO3dCQUNWWCxRQUFRWixLQUFLLENBQUMseUNBQXlDdUI7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LGlEQUFVQSxDQUFDSztBQUNwQjtJQUZnQjJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9Vc2VyQ29udGV4dC50c3g/NWVlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InO1xuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSc7XG5cbi8vIE5vIG5lZWQgdG8gcmVkZWZpbmUgdGhlIFdpbmRvdyBpbnRlcmZhY2UgYXMgaXQncyBhbHJlYWR5IGRlZmluZWQgaW4gZ2xvYmFsLmQudHNcblxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgc3RhcnNfYmFsYW5jZTogbnVtYmVyO1xuICB1c2VyX2lkOiBzdHJpbmc7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIGJhbGFuY2U6IG51bWJlcjtcbiAgc29sYW5hX2JhbGFuY2U6IG51bWJlcjtcbiAgZW5lcmd5OiBudW1iZXI7XG4gIHNwaW5fZW5lcmd5OiBudW1iZXI7XG4gIGxhc3Rfc3Bpbl9lbmVyZ3lfcmVzZXQ6IHN0cmluZyB8IG51bGw7XG4gIGxhc3RfZW5lcmd5X3Jlc2V0OiBzdHJpbmcgfCBudWxsO1xuICBsYXN0X3RhcF90aW1lOiBzdHJpbmcgfCBudWxsO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbiAgbGV2ZWw6IHN0cmluZztcbiAgaXNfYWRtaW46IGJvb2xlYW47XG4gIHNvbGFuYV9hZGRyZXNzOiBzdHJpbmcgfCBudWxsO1xuICBtaW5pbmdfcmF0ZTogbnVtYmVyO1xuICB0ZWxlZ3JhbV9pZDogc3RyaW5nIHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIFVzZXJDb250ZXh0VHlwZSB7XG4gIHVzZXI6IFVzZXIgfCBudWxsO1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogYW55O1xuICBtdXRhdGU6ICgpID0+IFByb21pc2U8YW55Pjtcbn1cblxuY29uc3QgVXNlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZXJDb250ZXh0VHlwZT4oe1xuICB1c2VyOiBudWxsLFxuICBsb2FkaW5nOiBmYWxzZSxcbiAgZXJyb3I6IG51bGwsXG4gIG11dGF0ZTogYXN5bmMgKCkgPT4ge30sXG59KTtcblxuY29uc3QgSU5JVElBTF9TUElOX0VORVJHWSA9IDEyMDA7XG4vLyBBZG1pbiBJRCBmb3IgcmVmZXJlbmNlXG5jb25zdCBBRE1JTl9JRCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FETUlOX0lEIHx8ICc3MDkzNzkzNDU0JztcblxuZXhwb3J0IGZ1bmN0aW9uIFVzZXJQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFt0ZWxlZ3JhbVVzZXJJZCwgc2V0VGVsZWdyYW1Vc2VySWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIFxuICAvLyBFeHRyYWN0IFRlbGVncmFtIHVzZXIgSUQgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZ2V0VGVsZWdyYW1Vc2VyID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gZ2V0IFRlbGVncmFtIHVzZXIgSUQuLi4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIHRoZSBUZWxlZ3JhbSBXZWJBcHAgZW52aXJvbm1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5UZWxlZ3JhbSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdUZWxlZ3JhbSBXZWJBcHAgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IHVzZXIgZnJvbSBUZWxlZ3JhbSBXZWJBcHBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXNlIHR5cGUgYXNzZXJ0aW9uIHRvIGFjY2VzcyBwb3RlbnRpYWxseSB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgY29uc3Qgd2ViQXBwID0gd2luZG93LlRlbGVncmFtLldlYkFwcDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHdlYkFwcCAmJiB3ZWJBcHAuaW5pdERhdGFVbnNhZmUgJiYgd2ViQXBwLmluaXREYXRhVW5zYWZlLnVzZXIpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd2ViQXBwVXNlciA9IHdlYkFwcC5pbml0RGF0YVVuc2FmZS51c2VyO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHdlYkFwcFVzZXIgJiYgd2ViQXBwVXNlci5pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJJZCA9IFN0cmluZyh3ZWJBcHBVc2VyLmlkKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgVGVsZWdyYW0gdXNlciBmcm9tIFdlYkFwcDonLCB1c2VySWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VySWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhY2Nlc3NpbmcgVGVsZWdyYW0gV2ViQXBwIGRhdGE6JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHdlIGNhbid0IGdldCB0aGUgdXNlciBmcm9tIFdlYkFwcCwgdHJ5IHRvIHBhcnNlIGl0IGZyb20gdGhlIFVSTFxuICAgICAgICAgIGNvbnN0IHRnV2ViQXBwRGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkuZ2V0KCd0Z1dlYkFwcERhdGEnKTtcbiAgICAgICAgICBpZiAodGdXZWJBcHBEYXRhKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCB1c2VyX2lkIGZyb20gdGdXZWJBcHBEYXRhXG4gICAgICAgICAgICAgIGNvbnN0IGRlY29kZWREYXRhID0gZGVjb2RlVVJJQ29tcG9uZW50KHRnV2ViQXBwRGF0YSk7XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJNYXRjaCA9IGRlY29kZWREYXRhLm1hdGNoKC9cImlkXCI6KFxcZCspLyk7XG4gICAgICAgICAgICAgIGlmICh1c2VyTWF0Y2ggJiYgdXNlck1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcklkID0gdXNlck1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBUZWxlZ3JhbSB1c2VyIGZyb20gdGdXZWJBcHBEYXRhOicsIHVzZXJJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHRnV2ViQXBwRGF0YTonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIFVSTCBwYXJhbWV0ZXJzIGFzIGZhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICAgICAgY29uc3QgdXNlcklkRnJvbVVybCA9IHVybFBhcmFtcy5nZXQoJ3VzZXJfaWQnKSB8fCB1cmxQYXJhbXMuZ2V0KCdpZCcpO1xuICAgICAgICAgIGlmICh1c2VySWRGcm9tVXJsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgdXNlcl9pZCBpbiBVUkw6JywgdXNlcklkRnJvbVVybCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlcklkRnJvbVVybDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCB1c2VyX2lkIGZyb20gaGFzaFxuICAgICAgICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICBjb25zdCBoYXNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhoYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgY29uc3QgdXNlcklkRnJvbUhhc2ggPSBoYXNoUGFyYW1zLmdldCgndXNlcl9pZCcpIHx8IGhhc2hQYXJhbXMuZ2V0KCdpZCcpO1xuICAgICAgICAgIGlmICh1c2VySWRGcm9tSGFzaCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHVzZXJfaWQgaW4gaGFzaDonLCB1c2VySWRGcm9tSGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlcklkRnJvbUhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBnZXQgZnJvbSBsb2NhbFN0b3JhZ2UgKGlmIHByZXZpb3VzbHkgc2F2ZWQpXG4gICAgICAgICAgY29uc3Qgc2F2ZWRVc2VySWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndGVsZWdyYW1fdXNlcl9pZCcpO1xuICAgICAgICAgIGlmIChzYXZlZFVzZXJJZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHVzZXJfaWQgaW4gbG9jYWxTdG9yYWdlOicsIHNhdmVkVXNlcklkKTtcbiAgICAgICAgICAgIHJldHVybiBzYXZlZFVzZXJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZvciBkZXZlbG9wbWVudC90ZXN0aW5nIG9ubHkgLSBETyBOT1QgdXNlIGluIHByb2R1Y3Rpb25cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0RldmVsb3BtZW50IGVudmlyb25tZW50IGRldGVjdGVkLCB1c2luZyB0ZXN0IHVzZXIgSUQnKTtcbiAgICAgICAgICBjb25zdCB0ZXN0SWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndGVzdF91c2VyX2lkJykgfHwgJ3Rlc3RfdXNlcic7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rlc3RfdXNlcl9pZCcsIHRlc3RJZCk7XG4gICAgICAgICAgcmV0dXJuIHRlc3RJZDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBUZWxlZ3JhbSB1c2VyIElEIGZvdW5kLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBkZXZlbG9wbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIFRlbGVncmFtIHVzZXI6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHVzZXJJZCA9IGdldFRlbGVncmFtVXNlcigpO1xuICAgIGlmICh1c2VySWQpIHtcbiAgICAgIHNldFRlbGVncmFtVXNlcklkKHVzZXJJZCk7XG4gICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZSBmb3IgcGVyc2lzdGVuY2VcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndGVsZWdyYW1fdXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygnU2V0IFRlbGVncmFtIHVzZXIgSUQ6JywgdXNlcklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBhIHZhbGlkIHVzZXIgSUQnKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCB7IGRhdGE6IHVzZXIsIGVycm9yLCBpc0xvYWRpbmcsIG11dGF0ZSB9ID0gdXNlU1dSKFxuICAgIHRlbGVncmFtVXNlcklkID8gWyd1c2VyJywgdGVsZWdyYW1Vc2VySWRdIDogbnVsbCwgXG4gICAgYXN5bmMgKFtfLCB1c2VySWRdKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgdXNlciBkYXRhIGZvciBJRDonLCB1c2VySWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QsIGNoZWNrIGlmIHVzZXIgZXhpc3RzXG4gICAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdVc2VyLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0V4aXN0aW5nIHVzZXIgZGF0YTonLCBleGlzdGluZ1VzZXIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGZldGNoRXJyb3IpIHtcbiAgICAgICAgICBpZiAoZmV0Y2hFcnJvci5jb2RlID09PSAnUEdSU1QxMTYnKSB7IC8vIE5vdCBmb3VuZCBlcnJvclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgbm90IGZvdW5kLCBjcmVhdGluZyBuZXcgdXNlci4uLicpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB1c2VyIHdpdGggaW5pdGlhbCBzcGluIGVuZXJneVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBuZXdVc2VyLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICB0ZWxlZ3JhbV9pZDogdXNlcklkLCAvLyBTdG9yZSB0aGUgdGVsZWdyYW1faWQgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgIGJhbGFuY2U6IDAsXG4gICAgICAgICAgICAgICAgc29sYW5hX2JhbGFuY2U6IDAsXG4gICAgICAgICAgICAgICAgZW5lcmd5OiAxMjAwLFxuICAgICAgICAgICAgICAgIHNwaW5fZW5lcmd5OiBJTklUSUFMX1NQSU5fRU5FUkdZLFxuICAgICAgICAgICAgICAgIGxhc3Rfc3Bpbl9lbmVyZ3lfcmVzZXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBsZXZlbDogJzEnLFxuICAgICAgICAgICAgICAgIGlzX2FkbWluOiB1c2VySWQgPT09IEFETUlOX0lELCAvLyBPbmx5IHNldCBhZG1pbiBpZiBpdCBtYXRjaGVzIEFETUlOX0lEXG4gICAgICAgICAgICAgICAgbWluaW5nX2VxdWlwbWVudDoge30sIC8vIEluaXRpYWxpemUgZW1wdHkgbWluaW5nIGVxdWlwbWVudFxuICAgICAgICAgICAgICAgIG1pbmluZ19yYXRlOiAwIC8vIEluaXRpYWxpemUgbWluaW5nIHJhdGUgdG8gMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgbmV3IHVzZXI6JywgY3JlYXRlRXJyb3IpO1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOZXcgdXNlciBjcmVhdGVkOicsIG5ld1VzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1VzZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGZldGNoRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB1c2VyIGV4aXN0cyBidXQgaGFzIG5vIHRlbGVncmFtX2lkLCB1cGRhdGUgaXRcbiAgICAgICAgaWYgKGV4aXN0aW5nVXNlciAmJiAhZXhpc3RpbmdVc2VyLnRlbGVncmFtX2lkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHVzZXIgd2l0aCB0ZWxlZ3JhbV9pZC4uLicpO1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlZFVzZXIsIGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgdGVsZWdyYW1faWQ6IHVzZXJJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB1c2VyIHRlbGVncmFtX2lkOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgdXBkYXRlZCB3aXRoIHRlbGVncmFtX2lkOicsIHVwZGF0ZWRVc2VyKTtcbiAgICAgICAgICAgIGV4aXN0aW5nVXNlci50ZWxlZ3JhbV9pZCA9IHVzZXJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB1c2VyIGV4aXN0cyBidXQgaGFzIG5vIHNwaW4gZW5lcmd5LCB1cGRhdGUgdGhlbVxuICAgICAgICBpZiAoZXhpc3RpbmdVc2VyICYmIChleGlzdGluZ1VzZXIuc3Bpbl9lbmVyZ3kgPT09IHVuZGVmaW5lZCB8fCBleGlzdGluZ1VzZXIuc3Bpbl9lbmVyZ3kgPT09IG51bGwgfHwgZXhpc3RpbmdVc2VyLnNwaW5fZW5lcmd5ID09PSAwKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyB1c2VyIHdpdGggc3BpbiBlbmVyZ3kuLi4nKTtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZWRVc2VyLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIHNwaW5fZW5lcmd5OiBJTklUSUFMX1NQSU5fRU5FUkdZLFxuICAgICAgICAgICAgICBsYXN0X3NwaW5fZW5lcmd5X3Jlc2V0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHVzZXI6JywgdXBkYXRlRXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgdXBkYXRlRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHVwZGF0ZWQgd2l0aCBzcGluIGVuZXJneTonLCB1cGRhdGVkVXNlcik7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZWRVc2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZW5lcmd5IG5lZWRzIHRvIGJlIHJlc2V0ICgxMiBob3VycyBwYXNzZWQpXG4gICAgICAgIGlmIChleGlzdGluZ1VzZXIubGFzdF9zcGluX2VuZXJneV9yZXNldCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RSZXNldCA9IG5ldyBEYXRlKGV4aXN0aW5nVXNlci5sYXN0X3NwaW5fZW5lcmd5X3Jlc2V0KTtcbiAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IGhvdXJzU2luY2VSZXNldCA9IChub3cuZ2V0VGltZSgpIC0gbGFzdFJlc2V0LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChob3Vyc1NpbmNlUmVzZXQgPj0gMTIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXNldHRpbmcgc3BpbiBlbmVyZ3kgYWZ0ZXIgMTIgaG91cnMuLi4nKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzZXRVc2VyLCBlcnJvcjogcmVzZXRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc3Bpbl9lbmVyZ3k6IElOSVRJQUxfU1BJTl9FTkVSR1ksXG4gICAgICAgICAgICAgICAgbGFzdF9zcGluX2VuZXJneV9yZXNldDogbm93LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgICAgICAgaWYgKHJlc2V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzZXR0aW5nIGVuZXJneTonLCByZXNldEVycm9yKTtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzZXRFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFbmVyZ3kgcmVzZXQgY29tcGxldGU6JywgcmVzZXRVc2VyKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldFVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIGlzX2FkbWluIGlzIGNvcnJlY3RseSBzZXRcbiAgICAgICAgaWYgKGV4aXN0aW5nVXNlci5pc19hZG1pbiA9PT0gdHJ1ZSAmJiB1c2VySWQgIT09IEFETUlOX0lEKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0ZpeGluZyBpbmNvcnJlY3QgYWRtaW4gc3RhdHVzIGZvciB1c2VyOicsIHVzZXJJZCk7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBmaXhlZFVzZXIsIGVycm9yOiBmaXhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgaXNfYWRtaW46IHVzZXJJZCA9PT0gQURNSU5fSURcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgIGlmIChmaXhFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZml4aW5nIGFkbWluIHN0YXR1czonLCBmaXhFcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXhlZFVzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZG1pbiBzdGF0dXMgZml4ZWQgZm9yIHVzZXI6JywgZml4ZWRVc2VyKTtcbiAgICAgICAgICAgIHJldHVybiBmaXhlZFVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZXhpc3RpbmdVc2VyO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXNlciBkYXRhIGZldGNoaW5nOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICByZXZhbGlkYXRlT25Gb2N1czogZmFsc2UsXG4gICAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IGZhbHNlLFxuICAgICAgcmVmcmVzaEludGVydmFsOiA2MDAwMCwgLy8gUmVmcmVzaCBldmVyeSBtaW51dGVcbiAgICB9XG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8VXNlckNvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIHVzZXIsXG4gICAgICAgIGxvYWRpbmc6IGlzTG9hZGluZyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIG11dGF0ZSxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvVXNlckNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVc2VyKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChVc2VyQ29udGV4dCk7XG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VTV1IiLCJzdXBhYmFzZSIsIlVzZXJDb250ZXh0IiwidXNlciIsImxvYWRpbmciLCJlcnJvciIsIm11dGF0ZSIsIklOSVRJQUxfU1BJTl9FTkVSR1kiLCJBRE1JTl9JRCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BRE1JTl9JRCIsIlVzZXJQcm92aWRlciIsImNoaWxkcmVuIiwidGVsZWdyYW1Vc2VySWQiLCJzZXRUZWxlZ3JhbVVzZXJJZCIsImdldFRlbGVncmFtVXNlciIsImNvbnNvbGUiLCJsb2ciLCJ3aW5kb3ciLCJUZWxlZ3JhbSIsIndlYkFwcCIsIldlYkFwcCIsImluaXREYXRhVW5zYWZlIiwid2ViQXBwVXNlciIsImlkIiwidXNlcklkIiwiU3RyaW5nIiwiZSIsInRnV2ViQXBwRGF0YSIsIlVSTFNlYXJjaFBhcmFtcyIsImxvY2F0aW9uIiwic2VhcmNoIiwiZ2V0IiwiZGVjb2RlZERhdGEiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ1c2VyTWF0Y2giLCJtYXRjaCIsInVybFBhcmFtcyIsInVzZXJJZEZyb21VcmwiLCJoYXNoIiwiaGFzaFBhcmFtcyIsInN1YnN0cmluZyIsInVzZXJJZEZyb21IYXNoIiwic2F2ZWRVc2VySWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidGVzdElkIiwic2V0SXRlbSIsIndhcm4iLCJkYXRhIiwiaXNMb2FkaW5nIiwiXyIsImV4aXN0aW5nVXNlciIsImZldGNoRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJjb2RlIiwibmV3VXNlciIsImNyZWF0ZUVycm9yIiwiaW5zZXJ0IiwidXNlcl9pZCIsInRlbGVncmFtX2lkIiwiYmFsYW5jZSIsInNvbGFuYV9iYWxhbmNlIiwiZW5lcmd5Iiwic3Bpbl9lbmVyZ3kiLCJsYXN0X3NwaW5fZW5lcmd5X3Jlc2V0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibGV2ZWwiLCJpc19hZG1pbiIsIm1pbmluZ19lcXVpcG1lbnQiLCJtaW5pbmdfcmF0ZSIsInVwZGF0ZWRVc2VyIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJ1bmRlZmluZWQiLCJsYXN0UmVzZXQiLCJub3ciLCJob3Vyc1NpbmNlUmVzZXQiLCJnZXRUaW1lIiwicmVzZXRVc2VyIiwicmVzZXRFcnJvciIsImZpeGVkVXNlciIsImZpeEVycm9yIiwicmV2YWxpZGF0ZU9uRm9jdXMiLCJyZXZhbGlkYXRlT25SZWNvbm5lY3QiLCJyZWZyZXNoSW50ZXJ2YWwiLCJQcm92aWRlciIsInZhbHVlIiwidXNlVXNlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/UserContext.tsx\n"));

/***/ })

});