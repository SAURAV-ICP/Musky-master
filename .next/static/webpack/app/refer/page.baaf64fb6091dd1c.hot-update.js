"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/refer/page",{

/***/ "(app-pages-browser)/./src/contexts/UserContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/UserContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UserProvider: function() { return /* binding */ UserProvider; },\n/* harmony export */   useUser: function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/dist/index/index.mjs\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ UserProvider,useUser auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst UserContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    user: null,\n    loading: false,\n    error: null,\n    mutate: async ()=>{},\n    updateWalletAddress: async ()=>false\n});\nconst INITIAL_SPIN_ENERGY = 1200;\n// Admin ID for reference\nconst ADMIN_ID = \"7093793454\" || 0;\nfunction UserProvider(param) {\n    let { children } = param;\n    _s();\n    const [telegramUserId, setTelegramUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Extract Telegram user ID when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const getTelegramUser = ()=>{\n            try {\n                console.log(\"Attempting to get Telegram user ID...\");\n                // Check if we're in the Telegram WebApp environment\n                if ( true && window.Telegram) {\n                    console.log(\"Telegram WebApp detected\");\n                    // Try to get user from Telegram WebApp\n                    try {\n                        // Use type assertion to access potentially undefined properties\n                        const webApp = window.Telegram.WebApp;\n                        if (webApp && webApp.initDataUnsafe && webApp.initDataUnsafe.user) {\n                            const webAppUser = webApp.initDataUnsafe.user;\n                            if (webAppUser && webAppUser.id) {\n                                const userId = String(webAppUser.id);\n                                console.log(\"Found Telegram user from WebApp:\", userId);\n                                return userId;\n                            }\n                        }\n                    } catch (e) {\n                        console.error(\"Error accessing Telegram WebApp data:\", e);\n                    }\n                    // If we can't get the user from WebApp, try to parse it from the URL\n                    const tgWebAppData = new URLSearchParams(window.location.search).get(\"tgWebAppData\");\n                    if (tgWebAppData) {\n                        try {\n                            // Try to extract user_id from tgWebAppData\n                            const decodedData = decodeURIComponent(tgWebAppData);\n                            const userMatch = decodedData.match(/\"id\":(\\d+)/);\n                            if (userMatch && userMatch[1]) {\n                                const userId = userMatch[1];\n                                console.log(\"Found Telegram user from tgWebAppData:\", userId);\n                                return userId;\n                            }\n                        } catch (e) {\n                            console.error(\"Error parsing tgWebAppData:\", e);\n                        }\n                    }\n                }\n                // Check URL parameters as fallback\n                if (true) {\n                    const urlParams = new URLSearchParams(window.location.search);\n                    const userIdFromUrl = urlParams.get(\"user_id\") || urlParams.get(\"id\");\n                    if (userIdFromUrl) {\n                        console.log(\"Found user_id in URL:\", userIdFromUrl);\n                        return userIdFromUrl;\n                    }\n                    // Try to get user_id from hash\n                    const hash = window.location.hash;\n                    const hashParams = new URLSearchParams(hash.substring(1));\n                    const userIdFromHash = hashParams.get(\"user_id\") || hashParams.get(\"id\");\n                    if (userIdFromHash) {\n                        console.log(\"Found user_id in hash:\", userIdFromHash);\n                        return userIdFromHash;\n                    }\n                    // Try to get from localStorage (if previously saved)\n                    const savedUserId = localStorage.getItem(\"telegram_user_id\");\n                    if (savedUserId) {\n                        console.log(\"Found user_id in localStorage:\", savedUserId);\n                        return savedUserId;\n                    }\n                }\n                // For development/testing only - DO NOT use in production\n                if (true) {\n                    console.log(\"Development environment detected, using test user ID\");\n                    const testId = localStorage.getItem(\"test_user_id\") || \"test_user\";\n                    localStorage.setItem(\"test_user_id\", testId);\n                    return testId;\n                }\n                console.warn(\"No Telegram user ID found. This should only happen in development.\");\n                return null;\n            } catch (error) {\n                console.error(\"Error getting Telegram user:\", error);\n                return null;\n            }\n        };\n        const userId = getTelegramUser();\n        if (userId) {\n            setTelegramUserId(userId);\n            // Save to localStorage for persistence\n            if (true) {\n                localStorage.setItem(\"telegram_user_id\", userId);\n            }\n            console.log(\"Set Telegram user ID:\", userId);\n        } else {\n            console.error(\"Failed to get a valid user ID\");\n        }\n    }, []);\n    const { data: user, error, isLoading, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(telegramUserId ? [\n        \"user\",\n        telegramUserId\n    ] : null, async (param)=>{\n        let [_, userId] = param;\n        try {\n            console.log(\"Fetching user data for ID:\", userId);\n            // First, check if user exists\n            const { data: existingUser, error: fetchError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").select(\"*\").eq(\"user_id\", userId).single();\n            console.log(\"Existing user data:\", existingUser);\n            if (fetchError) {\n                if (fetchError.code === \"PGRST116\") {\n                    console.log(\"User not found, creating new user...\");\n                    // Create new user with initial spin energy\n                    const { data: newUser, error: createError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").insert({\n                        user_id: userId,\n                        telegram_id: userId,\n                        balance: 0,\n                        solana_balance: 0,\n                        energy: 1200,\n                        spin_energy: INITIAL_SPIN_ENERGY,\n                        last_spin_energy_reset: new Date().toISOString(),\n                        level: \"1\",\n                        is_admin: userId === ADMIN_ID,\n                        mining_equipment: {},\n                        mining_rate: 0 // Initialize mining rate to 0\n                    }).select().single();\n                    if (createError) {\n                        console.error(\"Error creating new user:\", createError);\n                        throw createError;\n                    }\n                    console.log(\"New user created:\", newUser);\n                    return newUser;\n                }\n                throw fetchError;\n            }\n            // If user exists but has no telegram_id, update it\n            if (existingUser && !existingUser.telegram_id) {\n                console.log(\"Updating user with telegram_id...\");\n                const { data: updatedUser, error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    telegram_id: userId\n                }).eq(\"user_id\", userId).select().single();\n                if (updateError) {\n                    console.error(\"Error updating user telegram_id:\", updateError);\n                } else {\n                    console.log(\"User updated with telegram_id:\", updatedUser);\n                    existingUser.telegram_id = userId;\n                }\n            }\n            // If user exists but has no spin energy, update them\n            if (existingUser && (existingUser.spin_energy === undefined || existingUser.spin_energy === null || existingUser.spin_energy === 0)) {\n                console.log(\"Updating user with spin energy...\");\n                const { data: updatedUser, error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    spin_energy: INITIAL_SPIN_ENERGY,\n                    last_spin_energy_reset: new Date().toISOString()\n                }).eq(\"user_id\", userId).select().single();\n                if (updateError) {\n                    console.error(\"Error updating user:\", updateError);\n                    throw updateError;\n                }\n                console.log(\"User updated with spin energy:\", updatedUser);\n                return updatedUser;\n            }\n            // Check if energy needs to be reset (12 hours passed)\n            if (existingUser.last_spin_energy_reset) {\n                const lastReset = new Date(existingUser.last_spin_energy_reset);\n                const now = new Date();\n                const hoursSinceReset = (now.getTime() - lastReset.getTime()) / (1000 * 60 * 60);\n                if (hoursSinceReset >= 12) {\n                    console.log(\"Resetting spin energy after 12 hours...\");\n                    const { data: resetUser, error: resetError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                        spin_energy: INITIAL_SPIN_ENERGY,\n                        last_spin_energy_reset: now.toISOString()\n                    }).eq(\"user_id\", userId).select().single();\n                    if (resetError) {\n                        console.error(\"Error resetting energy:\", resetError);\n                        throw resetError;\n                    }\n                    console.log(\"Energy reset complete:\", resetUser);\n                    return resetUser;\n                }\n            }\n            // Ensure is_admin is correctly set\n            if (existingUser.is_admin === true && userId !== ADMIN_ID) {\n                console.log(\"Fixing incorrect admin status for user:\", userId);\n                const { data: fixedUser, error: fixError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                    is_admin: userId === ADMIN_ID\n                }).eq(\"user_id\", userId).select().single();\n                if (fixError) {\n                    console.error(\"Error fixing admin status:\", fixError);\n                } else if (fixedUser) {\n                    console.log(\"Admin status fixed for user:\", fixedUser);\n                    return fixedUser;\n                }\n            }\n            return existingUser;\n        } catch (error) {\n            console.error(\"Error in user data fetching:\", error);\n            throw error;\n        }\n    }, {\n        revalidateOnFocus: false,\n        revalidateOnReconnect: false,\n        refreshInterval: 60000\n    });\n    // Function to update wallet address\n    const updateWalletAddress = async (address)=>{\n        if (!user || !telegramUserId) {\n            console.error(\"Cannot update wallet address: User not logged in\");\n            return false;\n        }\n        try {\n            // Call the API endpoint to update the wallet address\n            const response = await fetch(\"/api/user/update-wallet\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    user_id: telegramUserId,\n                    wallet_address: address\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.error(\"Failed to update TON wallet address:\", errorData);\n                return false;\n            }\n            // Refresh user data\n            await mutate();\n            return true;\n        } catch (error) {\n            console.error(\"Error updating TON wallet address:\", error);\n            return false;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(UserContext.Provider, {\n        value: {\n            user,\n            loading: isLoading,\n            error,\n            mutate,\n            updateWalletAddress\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/sauravlamichhane/Downloads/Musky-master/src/contexts/UserContext.tsx\",\n        lineNumber: 338,\n        columnNumber: 5\n    }, this);\n}\n_s(UserProvider, \"/iEAPaFT06pkzI2vqU2cafQJ2aU=\", false, function() {\n    return [\n        swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    ];\n});\n_c = UserProvider;\nfunction useUser() {\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(UserContext);\n}\n_s1(useUser, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9Vc2VyQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRThFO0FBQ3JEO0FBQ2lCO0FBaUMxQyxNQUFNTyw0QkFBY04sb0RBQWFBLENBQWtCO0lBQ2pETyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxRQUFRLFdBQWE7SUFDckJDLHFCQUFxQixVQUFZO0FBQ25DO0FBRUEsTUFBTUMsc0JBQXNCO0FBQzVCLHlCQUF5QjtBQUN6QixNQUFNQyxXQUFXQyxZQUFnQyxJQUFJO0FBRTlDLFNBQVNHLGFBQWEsS0FBMkM7UUFBM0MsRUFBRUMsUUFBUSxFQUFpQyxHQUEzQzs7SUFDM0IsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHbEIsK0NBQVFBLENBQWdCO0lBRXBFLGlEQUFpRDtJQUNqREMsZ0RBQVNBLENBQUM7UUFDUixNQUFNa0Isa0JBQWtCO1lBQ3RCLElBQUk7Z0JBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztnQkFFWixvREFBb0Q7Z0JBQ3BELElBQUksS0FBa0IsSUFBZUMsT0FBT0MsUUFBUSxFQUFFO29CQUNwREgsUUFBUUMsR0FBRyxDQUFDO29CQUVaLHVDQUF1QztvQkFDdkMsSUFBSTt3QkFDRixnRUFBZ0U7d0JBQ2hFLE1BQU1HLFNBQVNGLE9BQU9DLFFBQVEsQ0FBQ0UsTUFBTTt3QkFFckMsSUFBSUQsVUFBVUEsT0FBT0UsY0FBYyxJQUFJRixPQUFPRSxjQUFjLENBQUNyQixJQUFJLEVBQUU7NEJBQ2pFLE1BQU1zQixhQUFhSCxPQUFPRSxjQUFjLENBQUNyQixJQUFJOzRCQUU3QyxJQUFJc0IsY0FBY0EsV0FBV0MsRUFBRSxFQUFFO2dDQUMvQixNQUFNQyxTQUFTQyxPQUFPSCxXQUFXQyxFQUFFO2dDQUNuQ1IsUUFBUUMsR0FBRyxDQUFDLG9DQUFvQ1E7Z0NBQ2hELE9BQU9BOzRCQUNUO3dCQUNGO29CQUNGLEVBQUUsT0FBT0UsR0FBRzt3QkFDVlgsUUFBUWIs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ckQsTUFBTXdGLFdBQVcsTUFBTUMsTUFBTSwyQkFBMkI7Z0JBQ3REQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFDbkJuQyxTQUFTakQ7b0JBQ1RxRixnQkFBZ0JSO2dCQUNsQjtZQUNGO1lBRUEsSUFBSSxDQUFDQyxTQUFTUSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVQsU0FBU1UsSUFBSTtnQkFDckNyRixRQUFRYixLQUFLLENBQUMsd0NBQXdDaUc7Z0JBQ3RELE9BQU87WUFDVDtZQUVBLG9CQUFvQjtZQUNwQixNQUFNaEc7WUFDTixPQUFPO1FBQ1QsRUFBRSxPQUFPRCxPQUFPO1lBQ2RhLFFBQVFiLEtBQUssQ0FBQyxzQ0FBc0NBO1lBQ3BELE9BQU87UUFDVDtJQUNGO0lBRUEscUJBQ0UsOERBQUNILFlBQVlzRyxRQUFRO1FBQ25CQyxPQUFPO1lBQ0x0RztZQUNBQyxTQUFTZ0Q7WUFDVC9DO1lBQ0FDO1lBQ0FDO1FBQ0Y7a0JBRUNPOzs7Ozs7QUFHUDtHQTVTZ0JEOztRQXdHbUNiLDJDQUFNQTs7O0tBeEd6Q2E7QUE4U1QsU0FBUzZGOztJQUNkLE9BQU83RyxpREFBVUEsQ0FBQ0s7QUFDcEI7SUFGZ0J3RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29udGV4dHMvVXNlckNvbnRleHQudHN4PzVlZTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJztcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG4vLyBObyBuZWVkIHRvIHJlZGVmaW5lIHRoZSBXaW5kb3cgaW50ZXJmYWNlIGFzIGl0J3MgYWxyZWFkeSBkZWZpbmVkIGluIGdsb2JhbC5kLnRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIHN0YXJzX2JhbGFuY2U6IG51bWJlcjtcbiAgdXNlcl9pZDogc3RyaW5nO1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBiYWxhbmNlOiBudW1iZXI7XG4gIHNvbGFuYV9iYWxhbmNlOiBudW1iZXI7XG4gIGVuZXJneTogbnVtYmVyO1xuICBzcGluX2VuZXJneTogbnVtYmVyO1xuICBsYXN0X3NwaW5fZW5lcmd5X3Jlc2V0OiBzdHJpbmcgfCBudWxsO1xuICBsYXN0X2VuZXJneV9yZXNldDogc3RyaW5nIHwgbnVsbDtcbiAgbGFzdF90YXBfdGltZTogc3RyaW5nIHwgbnVsbDtcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG4gIGxldmVsOiBzdHJpbmc7XG4gIGlzX2FkbWluOiBib29sZWFuO1xuICBzb2xhbmFfYWRkcmVzczogc3RyaW5nIHwgbnVsbDtcbiAgdG9uX2FkZHJlc3M6IHN0cmluZyB8IG51bGw7XG4gIG1pbmluZ19yYXRlOiBudW1iZXI7XG4gIHRlbGVncmFtX2lkOiBzdHJpbmcgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgVXNlckNvbnRleHRUeXBlIHtcbiAgdXNlcjogVXNlciB8IG51bGw7XG4gIGxvYWRpbmc6IGJvb2xlYW47XG4gIGVycm9yOiBhbnk7XG4gIG11dGF0ZTogKCkgPT4gUHJvbWlzZTxhbnk+O1xuICB1cGRhdGVXYWxsZXRBZGRyZXNzOiAoYWRkcmVzczogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xufVxuXG5jb25zdCBVc2VyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlckNvbnRleHRUeXBlPih7XG4gIHVzZXI6IG51bGwsXG4gIGxvYWRpbmc6IGZhbHNlLFxuICBlcnJvcjogbnVsbCxcbiAgbXV0YXRlOiBhc3luYyAoKSA9PiB7fSxcbiAgdXBkYXRlV2FsbGV0QWRkcmVzczogYXN5bmMgKCkgPT4gZmFsc2UsXG59KTtcblxuY29uc3QgSU5JVElBTF9TUElOX0VORVJHWSA9IDEyMDA7XG4vLyBBZG1pbiBJRCBmb3IgcmVmZXJlbmNlXG5jb25zdCBBRE1JTl9JRCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FETUlOX0lEIHx8ICc3MDkzNzkzNDU0JztcblxuZXhwb3J0IGZ1bmN0aW9uIFVzZXJQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFt0ZWxlZ3JhbVVzZXJJZCwgc2V0VGVsZWdyYW1Vc2VySWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIFxuICAvLyBFeHRyYWN0IFRlbGVncmFtIHVzZXIgSUQgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZ2V0VGVsZWdyYW1Vc2VyID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gZ2V0IFRlbGVncmFtIHVzZXIgSUQuLi4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIHRoZSBUZWxlZ3JhbSBXZWJBcHAgZW52aXJvbm1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5UZWxlZ3JhbSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdUZWxlZ3JhbSBXZWJBcHAgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IHVzZXIgZnJvbSBUZWxlZ3JhbSBXZWJBcHBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXNlIHR5cGUgYXNzZXJ0aW9uIHRvIGFjY2VzcyBwb3RlbnRpYWxseSB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgY29uc3Qgd2ViQXBwID0gd2luZG93LlRlbGVncmFtLldlYkFwcDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHdlYkFwcCAmJiB3ZWJBcHAuaW5pdERhdGFVbnNhZmUgJiYgd2ViQXBwLmluaXREYXRhVW5zYWZlLnVzZXIpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd2ViQXBwVXNlciA9IHdlYkFwcC5pbml0RGF0YVVuc2FmZS51c2VyO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHdlYkFwcFVzZXIgJiYgd2ViQXBwVXNlci5pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJJZCA9IFN0cmluZyh3ZWJBcHBVc2VyLmlkKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgVGVsZWdyYW0gdXNlciBmcm9tIFdlYkFwcDonLCB1c2VySWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VySWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhY2Nlc3NpbmcgVGVsZWdyYW0gV2ViQXBwIGRhdGE6JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHdlIGNhbid0IGdldCB0aGUgdXNlciBmcm9tIFdlYkFwcCwgdHJ5IHRvIHBhcnNlIGl0IGZyb20gdGhlIFVSTFxuICAgICAgICAgIGNvbnN0IHRnV2ViQXBwRGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkuZ2V0KCd0Z1dlYkFwcERhdGEnKTtcbiAgICAgICAgICBpZiAodGdXZWJBcHBEYXRhKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCB1c2VyX2lkIGZyb20gdGdXZWJBcHBEYXRhXG4gICAgICAgICAgICAgIGNvbnN0IGRlY29kZWREYXRhID0gZGVjb2RlVVJJQ29tcG9uZW50KHRnV2ViQXBwRGF0YSk7XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJNYXRjaCA9IGRlY29kZWREYXRhLm1hdGNoKC9cImlkXCI6KFxcZCspLyk7XG4gICAgICAgICAgICAgIGlmICh1c2VyTWF0Y2ggJiYgdXNlck1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcklkID0gdXNlck1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBUZWxlZ3JhbSB1c2VyIGZyb20gdGdXZWJBcHBEYXRhOicsIHVzZXJJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHRnV2ViQXBwRGF0YTonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIFVSTCBwYXJhbWV0ZXJzIGFzIGZhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICAgICAgY29uc3QgdXNlcklkRnJvbVVybCA9IHVybFBhcmFtcy5nZXQoJ3VzZXJfaWQnKSB8fCB1cmxQYXJhbXMuZ2V0KCdpZCcpO1xuICAgICAgICAgIGlmICh1c2VySWRGcm9tVXJsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgdXNlcl9pZCBpbiBVUkw6JywgdXNlcklkRnJvbVVybCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlcklkRnJvbVVybDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCB1c2VyX2lkIGZyb20gaGFzaFxuICAgICAgICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICBjb25zdCBoYXNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhoYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgY29uc3QgdXNlcklkRnJvbUhhc2ggPSBoYXNoUGFyYW1zLmdldCgndXNlcl9pZCcpIHx8IGhhc2hQYXJhbXMuZ2V0KCdpZCcpO1xuICAgICAgICAgIGlmICh1c2VySWRGcm9tSGFzaCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHVzZXJfaWQgaW4gaGFzaDonLCB1c2VySWRGcm9tSGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlcklkRnJvbUhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBnZXQgZnJvbSBsb2NhbFN0b3JhZ2UgKGlmIHByZXZpb3VzbHkgc2F2ZWQpXG4gICAgICAgICAgY29uc3Qgc2F2ZWRVc2VySWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndGVsZWdyYW1fdXNlcl9pZCcpO1xuICAgICAgICAgIGlmIChzYXZlZFVzZXJJZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHVzZXJfaWQgaW4gbG9jYWxTdG9yYWdlOicsIHNhdmVkVXNlcklkKTtcbiAgICAgICAgICAgIHJldHVybiBzYXZlZFVzZXJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZvciBkZXZlbG9wbWVudC90ZXN0aW5nIG9ubHkgLSBETyBOT1QgdXNlIGluIHByb2R1Y3Rpb25cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0RldmVsb3BtZW50IGVudmlyb25tZW50IGRldGVjdGVkLCB1c2luZyB0ZXN0IHVzZXIgSUQnKTtcbiAgICAgICAgICBjb25zdCB0ZXN0SWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndGVzdF91c2VyX2lkJykgfHwgJ3Rlc3RfdXNlcic7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rlc3RfdXNlcl9pZCcsIHRlc3RJZCk7XG4gICAgICAgICAgcmV0dXJuIHRlc3RJZDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBUZWxlZ3JhbSB1c2VyIElEIGZvdW5kLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBkZXZlbG9wbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIFRlbGVncmFtIHVzZXI6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHVzZXJJZCA9IGdldFRlbGVncmFtVXNlcigpO1xuICAgIGlmICh1c2VySWQpIHtcbiAgICAgIHNldFRlbGVncmFtVXNlcklkKHVzZXJJZCk7XG4gICAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZSBmb3IgcGVyc2lzdGVuY2VcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndGVsZWdyYW1fdXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygnU2V0IFRlbGVncmFtIHVzZXIgSUQ6JywgdXNlcklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBhIHZhbGlkIHVzZXIgSUQnKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCB7IGRhdGE6IHVzZXIsIGVycm9yLCBpc0xvYWRpbmcsIG11dGF0ZSB9ID0gdXNlU1dSKFxuICAgIHRlbGVncmFtVXNlcklkID8gWyd1c2VyJywgdGVsZWdyYW1Vc2VySWRdIDogbnVsbCwgXG4gICAgYXN5bmMgKFtfLCB1c2VySWRdKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgdXNlciBkYXRhIGZvciBJRDonLCB1c2VySWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QsIGNoZWNrIGlmIHVzZXIgZXhpc3RzXG4gICAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdVc2VyLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0V4aXN0aW5nIHVzZXIgZGF0YTonLCBleGlzdGluZ1VzZXIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGZldGNoRXJyb3IpIHtcbiAgICAgICAgICBpZiAoZmV0Y2hFcnJvci5jb2RlID09PSAnUEdSU1QxMTYnKSB7IC8vIE5vdCBmb3VuZCBlcnJvclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgbm90IGZvdW5kLCBjcmVhdGluZyBuZXcgdXNlci4uLicpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB1c2VyIHdpdGggaW5pdGlhbCBzcGluIGVuZXJneVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBuZXdVc2VyLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICB0ZWxlZ3JhbV9pZDogdXNlcklkLCAvLyBTdG9yZSB0aGUgdGVsZWdyYW1faWQgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgIGJhbGFuY2U6IDAsXG4gICAgICAgICAgICAgICAgc29sYW5hX2JhbGFuY2U6IDAsXG4gICAgICAgICAgICAgICAgZW5lcmd5OiAxMjAwLFxuICAgICAgICAgICAgICAgIHNwaW5fZW5lcmd5OiBJTklUSUFMX1NQSU5fRU5FUkdZLFxuICAgICAgICAgICAgICAgIGxhc3Rfc3Bpbl9lbmVyZ3lfcmVzZXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBsZXZlbDogJzEnLFxuICAgICAgICAgICAgICAgIGlzX2FkbWluOiB1c2VySWQgPT09IEFETUlOX0lELCAvLyBPbmx5IHNldCBhZG1pbiBpZiBpdCBtYXRjaGVzIEFETUlOX0lEXG4gICAgICAgICAgICAgICAgbWluaW5nX2VxdWlwbWVudDoge30sIC8vIEluaXRpYWxpemUgZW1wdHkgbWluaW5nIGVxdWlwbWVudFxuICAgICAgICAgICAgICAgIG1pbmluZ19yYXRlOiAwIC8vIEluaXRpYWxpemUgbWluaW5nIHJhdGUgdG8gMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICBpZiAoY3JlYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgbmV3IHVzZXI6JywgY3JlYXRlRXJyb3IpO1xuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOZXcgdXNlciBjcmVhdGVkOicsIG5ld1VzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1VzZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGZldGNoRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB1c2VyIGV4aXN0cyBidXQgaGFzIG5vIHRlbGVncmFtX2lkLCB1cGRhdGUgaXRcbiAgICAgICAgaWYgKGV4aXN0aW5nVXNlciAmJiAhZXhpc3RpbmdVc2VyLnRlbGVncmFtX2lkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHVzZXIgd2l0aCB0ZWxlZ3JhbV9pZC4uLicpO1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlZFVzZXIsIGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgdGVsZWdyYW1faWQ6IHVzZXJJZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB1c2VyIHRlbGVncmFtX2lkOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgdXBkYXRlZCB3aXRoIHRlbGVncmFtX2lkOicsIHVwZGF0ZWRVc2VyKTtcbiAgICAgICAgICAgIGV4aXN0aW5nVXNlci50ZWxlZ3JhbV9pZCA9IHVzZXJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB1c2VyIGV4aXN0cyBidXQgaGFzIG5vIHNwaW4gZW5lcmd5LCB1cGRhdGUgdGhlbVxuICAgICAgICBpZiAoZXhpc3RpbmdVc2VyICYmIChleGlzdGluZ1VzZXIuc3Bpbl9lbmVyZ3kgPT09IHVuZGVmaW5lZCB8fCBleGlzdGluZ1VzZXIuc3Bpbl9lbmVyZ3kgPT09IG51bGwgfHwgZXhpc3RpbmdVc2VyLnNwaW5fZW5lcmd5ID09PSAwKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyB1c2VyIHdpdGggc3BpbiBlbmVyZ3kuLi4nKTtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZWRVc2VyLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIHNwaW5fZW5lcmd5OiBJTklUSUFMX1NQSU5fRU5FUkdZLFxuICAgICAgICAgICAgICBsYXN0X3NwaW5fZW5lcmd5X3Jlc2V0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHVzZXI6JywgdXBkYXRlRXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgdXBkYXRlRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHVwZGF0ZWQgd2l0aCBzcGluIGVuZXJneTonLCB1cGRhdGVkVXNlcik7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZWRVc2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZW5lcmd5IG5lZWRzIHRvIGJlIHJlc2V0ICgxMiBob3VycyBwYXNzZWQpXG4gICAgICAgIGlmIChleGlzdGluZ1VzZXIubGFzdF9zcGluX2VuZXJneV9yZXNldCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RSZXNldCA9IG5ldyBEYXRlKGV4aXN0aW5nVXNlci5sYXN0X3NwaW5fZW5lcmd5X3Jlc2V0KTtcbiAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IGhvdXJzU2luY2VSZXNldCA9IChub3cuZ2V0VGltZSgpIC0gbGFzdFJlc2V0LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChob3Vyc1NpbmNlUmVzZXQgPj0gMTIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXNldHRpbmcgc3BpbiBlbmVyZ3kgYWZ0ZXIgMTIgaG91cnMuLi4nKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzZXRVc2VyLCBlcnJvcjogcmVzZXRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc3Bpbl9lbmVyZ3k6IElOSVRJQUxfU1BJTl9FTkVSR1ksXG4gICAgICAgICAgICAgICAgbGFzdF9zcGluX2VuZXJneV9yZXNldDogbm93LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgICAgICAgaWYgKHJlc2V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzZXR0aW5nIGVuZXJneTonLCByZXNldEVycm9yKTtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzZXRFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFbmVyZ3kgcmVzZXQgY29tcGxldGU6JywgcmVzZXRVc2VyKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldFVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIGlzX2FkbWluIGlzIGNvcnJlY3RseSBzZXRcbiAgICAgICAgaWYgKGV4aXN0aW5nVXNlci5pc19hZG1pbiA9PT0gdHJ1ZSAmJiB1c2VySWQgIT09IEFETUlOX0lEKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0ZpeGluZyBpbmNvcnJlY3QgYWRtaW4gc3RhdHVzIGZvciB1c2VyOicsIHVzZXJJZCk7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBmaXhlZFVzZXIsIGVycm9yOiBmaXhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgICAgaXNfYWRtaW46IHVzZXJJZCA9PT0gQURNSU5fSURcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgIGlmIChmaXhFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZml4aW5nIGFkbWluIHN0YXR1czonLCBmaXhFcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXhlZFVzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZG1pbiBzdGF0dXMgZml4ZWQgZm9yIHVzZXI6JywgZml4ZWRVc2VyKTtcbiAgICAgICAgICAgIHJldHVybiBmaXhlZFVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZXhpc3RpbmdVc2VyO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdXNlciBkYXRhIGZldGNoaW5nOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICByZXZhbGlkYXRlT25Gb2N1czogZmFsc2UsXG4gICAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6IGZhbHNlLFxuICAgICAgcmVmcmVzaEludGVydmFsOiA2MDAwMCwgLy8gUmVmcmVzaCBldmVyeSBtaW51dGVcbiAgICB9XG4gICk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIHdhbGxldCBhZGRyZXNzXG4gIGNvbnN0IHVwZGF0ZVdhbGxldEFkZHJlc3MgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgaWYgKCF1c2VyIHx8ICF0ZWxlZ3JhbVVzZXJJZCkge1xuICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHVwZGF0ZSB3YWxsZXQgYWRkcmVzczogVXNlciBub3QgbG9nZ2VkIGluJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENhbGwgdGhlIEFQSSBlbmRwb2ludCB0byB1cGRhdGUgdGhlIHdhbGxldCBhZGRyZXNzXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3VzZXIvdXBkYXRlLXdhbGxldCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlcl9pZDogdGVsZWdyYW1Vc2VySWQsXG4gICAgICAgICAgd2FsbGV0X2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIFRPTiB3YWxsZXQgYWRkcmVzczonLCBlcnJvckRhdGEpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZnJlc2ggdXNlciBkYXRhXG4gICAgICBhd2FpdCBtdXRhdGUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBUT04gd2FsbGV0IGFkZHJlc3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxVc2VyQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgdXNlcixcbiAgICAgICAgbG9hZGluZzogaXNMb2FkaW5nLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgbXV0YXRlLFxuICAgICAgICB1cGRhdGVXYWxsZXRBZGRyZXNzLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Vc2VyQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVzZXIoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFVzZXJDb250ZXh0KTtcbn0gIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVNXUiIsInN1cGFiYXNlIiwiVXNlckNvbnRleHQiLCJ1c2VyIiwibG9hZGluZyIsImVycm9yIiwibXV0YXRlIiwidXBkYXRlV2FsbGV0QWRkcmVzcyIsIklOSVRJQUxfU1BJTl9FTkVSR1kiLCJBRE1JTl9JRCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BRE1JTl9JRCIsIlVzZXJQcm92aWRlciIsImNoaWxkcmVuIiwidGVsZWdyYW1Vc2VySWQiLCJzZXRUZWxlZ3JhbVVzZXJJZCIsImdldFRlbGVncmFtVXNlciIsImNvbnNvbGUiLCJsb2ciLCJ3aW5kb3ciLCJUZWxlZ3JhbSIsIndlYkFwcCIsIldlYkFwcCIsImluaXREYXRhVW5zYWZlIiwid2ViQXBwVXNlciIsImlkIiwidXNlcklkIiwiU3RyaW5nIiwiZSIsInRnV2ViQXBwRGF0YSIsIlVSTFNlYXJjaFBhcmFtcyIsImxvY2F0aW9uIiwic2VhcmNoIiwiZ2V0IiwiZGVjb2RlZERhdGEiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ1c2VyTWF0Y2giLCJtYXRjaCIsInVybFBhcmFtcyIsInVzZXJJZEZyb21VcmwiLCJoYXNoIiwiaGFzaFBhcmFtcyIsInN1YnN0cmluZyIsInVzZXJJZEZyb21IYXNoIiwic2F2ZWRVc2VySWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidGVzdElkIiwic2V0SXRlbSIsIndhcm4iLCJkYXRhIiwiaXNMb2FkaW5nIiwiXyIsImV4aXN0aW5nVXNlciIsImZldGNoRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJjb2RlIiwibmV3VXNlciIsImNyZWF0ZUVycm9yIiwiaW5zZXJ0IiwidXNlcl9pZCIsInRlbGVncmFtX2lkIiwiYmFsYW5jZSIsInNvbGFuYV9iYWxhbmNlIiwiZW5lcmd5Iiwic3Bpbl9lbmVyZ3kiLCJsYXN0X3NwaW5fZW5lcmd5X3Jlc2V0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibGV2ZWwiLCJpc19hZG1pbiIsIm1pbmluZ19lcXVpcG1lbnQiLCJtaW5pbmdfcmF0ZSIsInVwZGF0ZWRVc2VyIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJ1bmRlZmluZWQiLCJsYXN0UmVzZXQiLCJub3ciLCJob3Vyc1NpbmNlUmVzZXQiLCJnZXRUaW1lIiwicmVzZXRVc2VyIiwicmVzZXRFcnJvciIsImZpeGVkVXNlciIsImZpeEVycm9yIiwicmV2YWxpZGF0ZU9uRm9jdXMiLCJyZXZhbGlkYXRlT25SZWNvbm5lY3QiLCJyZWZyZXNoSW50ZXJ2YWwiLCJhZGRyZXNzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIndhbGxldF9hZGRyZXNzIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZVVzZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/UserContext.tsx\n"));

/***/ })

});